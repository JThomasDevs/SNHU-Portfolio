My approach to software design is defined by the stated requirements of said software. As a solo developer, I do not often have the luxury of the "wisdom of the masses" and thus, when I am working with a new framework such as OpenGL, my design process happens in stages, with implementation and testing of features happening between each design stage. When working alone, this helps keep me on schedule as I design, build, and test features in small chunks which helps me spot errors earlier as I am only adding one or two functional pieces in each design stage. Working in small stages like this can be applied to my future work as I have done my best to mimic a "solo scrum" style in which I begin with a list of separate, implementable features as gathered from the stated requirements; design, build, and test a feature or two each cycle; and then move back to the feature list to examine which feature to implement next into the newest form of the software.

Especially when working with a new framework be it OpenGL or React, my approach to developing programs and consists largely of trial and error to examine the effect of specific lines of code or certain functions. While my approach to designing the program for this project is not much different than my usual development approach, I did utilize this strategy differently. Most of my trial-and-error coding for this project centered around properly orienting objects in 3D space to adequately mimic my source image rather than on how specific functions are implemented. Iteration factored into my development in this project as it does with most programs I build. Throughout the milestones and the projects, I would adjust a single metric or a single object to examine the effect it has on the overall 3D scene. Then, once the metric or object meets my standard of success, I move forward to the next item on my list of features to complete.

The knowledge gained in this course, while it may or may not be relevant in my eventual career, has provided me further insight to how computers work at a base level and how code and electric signals are translated into graphical, interactable elements that can be viewed on a screen. Knowing how a graphics pipeline is built and functions can aid in further understanding how computers work in general, with bits being moved and changed, and how we can take advantage of these processes to accomplish a specific goal - like rendering a bouncing ball inside of a window.